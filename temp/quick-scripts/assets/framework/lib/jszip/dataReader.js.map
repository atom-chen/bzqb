{"version":3,"sources":["dataReader.js"],"names":["utils","require","DataReader","data","length","index","prototype","checkOffset","offset","checkIndex","newIndex","Error","setIndex","skip","n","byteAt","i","readInt","size","result","readString","transformTo","readData","lastIndexOfSignature","sig","readDate","dostime","Date","module","exports"],"mappings":";;;;AAAA;;AACA,IAAIA,QAAQC,QAAQ,SAAR,CAAZ;;AAEA,SAASC,UAAT,CAAoBC,IAApB,EAA0B;AACtB,SAAKA,IAAL,GAAY,IAAZ,CADsB,CACJ;AAClB,SAAKC,MAAL,GAAc,CAAd;AACA,SAAKC,KAAL,GAAa,CAAb;AACH;AACDH,WAAWI,SAAX,GAAuB;AACnB;;;;;AAKAC,iBAAa,qBAASC,MAAT,EAAiB;AAC1B,aAAKC,UAAL,CAAgB,KAAKJ,KAAL,GAAaG,MAA7B;AACH,KARkB;AASnB;;;;;AAKAC,gBAAY,oBAASC,QAAT,EAAmB;AAC3B,YAAI,KAAKN,MAAL,GAAcM,QAAd,IAA0BA,WAAW,CAAzC,EAA4C;AACxC,kBAAM,IAAIC,KAAJ,CAAU,wCAAwC,KAAKP,MAA7C,GAAsD,kBAAtD,GAA4EM,QAA5E,GAAwF,oBAAlG,CAAN;AACH;AACJ,KAlBkB;AAmBnB;;;;;AAKAE,cAAU,kBAASF,QAAT,EAAmB;AACzB,aAAKD,UAAL,CAAgBC,QAAhB;AACA,aAAKL,KAAL,GAAaK,QAAb;AACH,KA3BkB;AA4BnB;;;;;AAKAG,UAAM,cAASC,CAAT,EAAY;AACd,aAAKF,QAAL,CAAc,KAAKP,KAAL,GAAaS,CAA3B;AACH,KAnCkB;AAoCnB;;;;;AAKAC,YAAQ,gBAASC,CAAT,EAAY;AAChB;AACH,KA3CkB;AA4CnB;;;;;AAKAC,aAAS,iBAASC,IAAT,EAAe;AACpB,YAAIC,SAAS,CAAb;AAAA,YACIH,CADJ;AAEA,aAAKT,WAAL,CAAiBW,IAAjB;AACA,aAAKF,IAAI,KAAKX,KAAL,GAAaa,IAAb,GAAoB,CAA7B,EAAgCF,KAAK,KAAKX,KAA1C,EAAiDW,GAAjD,EAAsD;AAClDG,qBAAS,CAACA,UAAU,CAAX,IAAgB,KAAKJ,MAAL,CAAYC,CAAZ,CAAzB;AACH;AACD,aAAKX,KAAL,IAAca,IAAd;AACA,eAAOC,MAAP;AACH,KA1DkB;AA2DnB;;;;;AAKAC,gBAAY,oBAASF,IAAT,EAAe;AACvB,eAAOlB,MAAMqB,WAAN,CAAkB,QAAlB,EAA4B,KAAKC,QAAL,CAAcJ,IAAd,CAA5B,CAAP;AACH,KAlEkB;AAmEnB;;;;;AAKAI,cAAU,kBAASJ,IAAT,EAAe;AACrB;AACH,KA1EkB;AA2EnB;;;;;AAKAK,0BAAsB,8BAASC,GAAT,EAAc;AAChC;AACH,KAlFkB;AAmFnB;;;;AAIAC,cAAU,oBAAW;AACjB,YAAIC,UAAU,KAAKT,OAAL,CAAa,CAAb,CAAd;AACA,eAAO,IAAIU,IAAJ,CACP,CAAED,WAAW,EAAZ,GAAkB,IAAnB,IAA2B,IADpB,EAC0B;AACjC,SAAEA,WAAW,EAAZ,GAAkB,IAAnB,IAA2B,CAFpB,EAEuB;AAC7BA,mBAAW,EAAZ,GAAkB,IAHX,EAGiB;AACvBA,mBAAW,EAAZ,GAAkB,IAJX,EAIiB;AACvBA,mBAAW,CAAZ,GAAiB,IALV,EAKgB;AACvB,SAACA,UAAU,IAAX,KAAoB,CANb,CAAP,CAFiB,CAQO;AAC3B;AAhGkB,CAAvB;AAkGAE,OAAOC,OAAP,GAAiB3B,UAAjB","file":"dataReader.js","sourceRoot":"..\\..\\..\\..\\..\\..\\assets\\framework\\lib\\jszip","sourcesContent":["'use strict';\nvar utils = require('./utils');\n\nfunction DataReader(data) {\n    this.data = null; // type : see implementation\n    this.length = 0;\n    this.index = 0;\n}\nDataReader.prototype = {\n    /**\n     * Check that the offset will not go too far.\n     * @param {string} offset the additional offset to check.\n     * @throws {Error} an Error if the offset is out of bounds.\n     */\n    checkOffset: function(offset) {\n        this.checkIndex(this.index + offset);\n    },\n    /**\n     * Check that the specifed index will not be too far.\n     * @param {string} newIndex the index to check.\n     * @throws {Error} an Error if the index is out of bounds.\n     */\n    checkIndex: function(newIndex) {\n        if (this.length < newIndex || newIndex < 0) {\n            throw new Error(\"End of data reached (data length = \" + this.length + \", asked index = \" + (newIndex) + \"). Corrupted zip ?\");\n        }\n    },\n    /**\n     * Change the index.\n     * @param {number} newIndex The new index.\n     * @throws {Error} if the new index is out of the data.\n     */\n    setIndex: function(newIndex) {\n        this.checkIndex(newIndex);\n        this.index = newIndex;\n    },\n    /**\n     * Skip the next n bytes.\n     * @param {number} n the number of bytes to skip.\n     * @throws {Error} if the new index is out of the data.\n     */\n    skip: function(n) {\n        this.setIndex(this.index + n);\n    },\n    /**\n     * Get the byte at the specified index.\n     * @param {number} i the index to use.\n     * @return {number} a byte.\n     */\n    byteAt: function(i) {\n        // see implementations\n    },\n    /**\n     * Get the next number with a given byte size.\n     * @param {number} size the number of bytes to read.\n     * @return {number} the corresponding number.\n     */\n    readInt: function(size) {\n        var result = 0,\n            i;\n        this.checkOffset(size);\n        for (i = this.index + size - 1; i >= this.index; i--) {\n            result = (result << 8) + this.byteAt(i);\n        }\n        this.index += size;\n        return result;\n    },\n    /**\n     * Get the next string with a given byte size.\n     * @param {number} size the number of bytes to read.\n     * @return {string} the corresponding string.\n     */\n    readString: function(size) {\n        return utils.transformTo(\"string\", this.readData(size));\n    },\n    /**\n     * Get raw data without conversion, <size> bytes.\n     * @param {number} size the number of bytes to read.\n     * @return {Object} the raw data, implementation specific.\n     */\n    readData: function(size) {\n        // see implementations\n    },\n    /**\n     * Find the last occurence of a zip signature (4 bytes).\n     * @param {string} sig the signature to find.\n     * @return {number} the index of the last occurence, -1 if not found.\n     */\n    lastIndexOfSignature: function(sig) {\n        // see implementations\n    },\n    /**\n     * Get the next date.\n     * @return {Date} the date.\n     */\n    readDate: function() {\n        var dostime = this.readInt(4);\n        return new Date(\n        ((dostime >> 25) & 0x7f) + 1980, // year\n        ((dostime >> 21) & 0x0f) - 1, // month\n        (dostime >> 16) & 0x1f, // day\n        (dostime >> 11) & 0x1f, // hour\n        (dostime >> 5) & 0x3f, // minute\n        (dostime & 0x1f) << 1); // second\n    }\n};\nmodule.exports = DataReader;\n"]}