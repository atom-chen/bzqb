{"version":3,"sources":["object.js"],"names":["support","require","utils","crc32","signature","defaults","base64","compressions","CompressedObject","nodeBuffer","utf8","StringWriter","Uint8ArrayWriter","getRawData","file","_data","getContent","options","binary","getTypeOf","copy","Uint8Array","length","set","getBinaryData","result","type","nodebuffer","asBinary","dataToString","asUTF8","decode","out","utf8decode","transformTo","utf8encode","ZipObject","name","data","dir","date","comment","unixPermissions","dosPermissions","_initialMetadata","prototype","asText","call","asNodeBuffer","asUint8Array","asArrayBuffer","buffer","decToHex","dec","bytes","hex","i","String","fromCharCode","extend","attr","arguments","hasOwnProperty","prepareFileAttrs","o","undefined","Date","compression","toUpperCase","fileAdd","dataType","parent","parseInt","forceTrailingSlash","createFolders","parentFolder","folderAdd","optimizedBinaryString","string2binary","Error","object","files","path","slice","substring","lastSlash","lastIndexOf","generateCompressedObjectFrom","compressionOptions","content","uncompressedSize","compressedContent","compressionMethod","magic","getCompressedContent","compress","compressInputType","compressedSize","generateUnixExternalFileAttr","isDir","generateDosExternalFileAttr","generateZipParts","compressedObject","offset","platform","utfEncodedFileName","utfEncodedComment","useUTF8ForFileName","useUTF8ForComment","dosTime","dosDate","extraFields","unicodePathExtraField","unicodeCommentExtraField","extFileAttr","versionMadeBy","getHours","getMinutes","getSeconds","getFullYear","getMonth","getDate","header","fileRecord","LOCAL_FILE_HEADER","dirRecord","CENTRAL_FILE_HEADER","load","stream","filter","search","filename","relativePath","fileClone","root","push","isRegExp","regexp","test","folder","arg","newFolder","ret","clone","remove","kids","generate","mimeType","checkSupport","zipData","localDirLength","centralDirLength","writer","compressionName","zipPart","dirEnd","CENTRAL_DIRECTORY_END","typeName","toLowerCase","append","zip","finalize","arrayBuffer2Blob","encode","input","crc","string","module","exports"],"mappings":"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","file":"object.js","sourceRoot":"..\\..\\..\\..\\..\\..\\assets\\framework\\lib\\jszip","sourcesContent":["'use strict';\nvar support = require('./support');\nvar utils = require('./utils');\nvar crc32 = require('./crc32');\nvar signature = require('./signature');\nvar defaults = require('./defaults');\nvar base64 = require('./base64');\nvar compressions = require('./compressions');\nvar CompressedObject = require('./compressedObject');\nvar nodeBuffer = require('./nodeBuffer');\nvar utf8 = require('./utf8');\nvar StringWriter = require('./stringWriter');\nvar Uint8ArrayWriter = require('./uint8ArrayWriter');\n\n/**\n * Returns the raw data of a ZipObject, decompress the content if necessary.\n * @param {ZipObject} file the file to use.\n * @return {String|ArrayBuffer|Uint8Array|Buffer} the data.\n */\nvar getRawData = function(file) {\n    if (file._data instanceof CompressedObject) {\n        file._data = file._data.getContent();\n        file.options.binary = true;\n        file.options.base64 = false;\n\n        if (utils.getTypeOf(file._data) === \"uint8array\") {\n            var copy = file._data;\n            // when reading an arraybuffer, the CompressedObject mechanism will keep it and subarray() a Uint8Array.\n            // if we request a file in the same format, we might get the same Uint8Array or its ArrayBuffer (the original zip file).\n            file._data = new Uint8Array(copy.length);\n            // with an empty Uint8Array, Opera fails with a \"Offset larger than array size\"\n            if (copy.length !== 0) {\n                file._data.set(copy, 0);\n            }\n        }\n    }\n    return file._data;\n};\n\n/**\n * Returns the data of a ZipObject in a binary form. If the content is an unicode string, encode it.\n * @param {ZipObject} file the file to use.\n * @return {String|ArrayBuffer|Uint8Array|Buffer} the data.\n */\nvar getBinaryData = function(file) {\n    var result = getRawData(file),\n        type = utils.getTypeOf(result);\n    if (type === \"string\") {\n        if (!file.options.binary) {\n            // unicode text !\n            // unicode string => binary string is a painful process, check if we can avoid it.\n            if (support.nodebuffer) {\n                return nodeBuffer(result, \"utf-8\");\n            }\n        }\n        return file.asBinary();\n    }\n    return result;\n};\n\n/**\n * Transform this._data into a string.\n * @param {function} filter a function String -> String, applied if not null on the result.\n * @return {String} the string representing this._data.\n */\nvar dataToString = function(asUTF8) {\n    var result = getRawData(this);\n    if (result === null || typeof result === \"undefined\") {\n        return \"\";\n    }\n    // if the data is a base64 string, we decode it before checking the encoding !\n    if (this.options.base64) {\n        result = base64.decode(result);\n    }\n    if (asUTF8 && this.options.binary) {\n        // JSZip.prototype.utf8decode supports arrays as input\n        // skip to array => string step, utf8decode will do it.\n        result = out.utf8decode(result);\n    }\n    else {\n        // no utf8 transformation, do the array => string step.\n        result = utils.transformTo(\"string\", result);\n    }\n\n    if (!asUTF8 && !this.options.binary) {\n        result = utils.transformTo(\"string\", out.utf8encode(result));\n    }\n    return result;\n};\n/**\n * A simple object representing a file in the zip file.\n * @constructor\n * @param {string} name the name of the file\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data\n * @param {Object} options the options of the file\n */\nvar ZipObject = function(name, data, options) {\n    this.name = name;\n    this.dir = options.dir;\n    this.date = options.date;\n    this.comment = options.comment;\n    this.unixPermissions = options.unixPermissions;\n    this.dosPermissions = options.dosPermissions;\n\n    this._data = data;\n    this.options = options;\n\n    /*\n     * This object contains initial values for dir and date.\n     * With them, we can check if the user changed the deprecated metadata in\n     * `ZipObject#options` or not.\n     */\n    this._initialMetadata = {\n      dir : options.dir,\n      date : options.date\n    };\n};\n\nZipObject.prototype = {\n    /**\n     * Return the content as UTF8 string.\n     * @return {string} the UTF8 string.\n     */\n    asText: function() {\n        return dataToString.call(this, true);\n    },\n    /**\n     * Returns the binary content.\n     * @return {string} the content as binary.\n     */\n    asBinary: function() {\n        return dataToString.call(this, false);\n    },\n    /**\n     * Returns the content as a nodejs Buffer.\n     * @return {Buffer} the content as a Buffer.\n     */\n    asNodeBuffer: function() {\n        var result = getBinaryData(this);\n        return utils.transformTo(\"nodebuffer\", result);\n    },\n    /**\n     * Returns the content as an Uint8Array.\n     * @return {Uint8Array} the content as an Uint8Array.\n     */\n    asUint8Array: function() {\n        var result = getBinaryData(this);\n        return utils.transformTo(\"uint8array\", result);\n    },\n    /**\n     * Returns the content as an ArrayBuffer.\n     * @return {ArrayBuffer} the content as an ArrayBufer.\n     */\n    asArrayBuffer: function() {\n        return this.asUint8Array().buffer;\n    }\n};\n\n/**\n * Transform an integer into a string in hexadecimal.\n * @private\n * @param {number} dec the number to convert.\n * @param {number} bytes the number of bytes to generate.\n * @returns {string} the result.\n */\nvar decToHex = function(dec, bytes) {\n    var hex = \"\",\n        i;\n    for (i = 0; i < bytes; i++) {\n        hex += String.fromCharCode(dec & 0xff);\n        dec = dec >>> 8;\n    }\n    return hex;\n};\n\n/**\n * Merge the objects passed as parameters into a new one.\n * @private\n * @param {...Object} var_args All objects to merge.\n * @return {Object} a new object with the data of the others.\n */\nvar extend = function() {\n    var result = {}, i, attr;\n    for (i = 0; i < arguments.length; i++) { // arguments is not enumerable in some browsers\n        for (attr in arguments[i]) {\n            if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === \"undefined\") {\n                result[attr] = arguments[i][attr];\n            }\n        }\n    }\n    return result;\n};\n\n/**\n * Transforms the (incomplete) options from the user into the complete\n * set of options to create a file.\n * @private\n * @param {Object} o the options from the user.\n * @return {Object} the complete set of options.\n */\nvar prepareFileAttrs = function(o) {\n    o = o || {};\n    if (o.base64 === true && (o.binary === null || o.binary === undefined)) {\n        o.binary = true;\n    }\n    o = extend(o, defaults);\n    o.date = o.date || new Date();\n    if (o.compression !== null) o.compression = o.compression.toUpperCase();\n\n    return o;\n};\n\n/**\n * Add a file in the current folder.\n * @private\n * @param {string} name the name of the file\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data of the file\n * @param {Object} o the options of the file\n * @return {Object} the new file.\n */\nvar fileAdd = function(name, data, o) {\n    // be sure sub folders exist\n    var dataType = utils.getTypeOf(data),\n        parent;\n\n    o = prepareFileAttrs(o);\n\n    if (typeof o.unixPermissions === \"string\") {\n        o.unixPermissions = parseInt(o.unixPermissions, 8);\n    }\n\n    // UNX_IFDIR  0040000 see zipinfo.c\n    if (o.unixPermissions && (o.unixPermissions & 0x4000)) {\n        o.dir = true;\n    }\n    // Bit 4    Directory\n    if (o.dosPermissions && (o.dosPermissions & 0x0010)) {\n        o.dir = true;\n    }\n\n    if (o.dir) {\n        name = forceTrailingSlash(name);\n    }\n\n    if (o.createFolders && (parent = parentFolder(name))) {\n        folderAdd.call(this, parent, true);\n    }\n\n    if (o.dir || data === null || typeof data === \"undefined\") {\n        o.base64 = false;\n        o.binary = false;\n        data = null;\n        dataType = null;\n    }\n    else if (dataType === \"string\") {\n        if (o.binary && !o.base64) {\n            // optimizedBinaryString == true means that the file has already been filtered with a 0xFF mask\n            if (o.optimizedBinaryString !== true) {\n                // this is a string, not in a base64 format.\n                // Be sure that this is a correct \"binary string\"\n                data = utils.string2binary(data);\n            }\n        }\n    }\n    else { // arraybuffer, uint8array, ...\n        o.base64 = false;\n        o.binary = true;\n\n        if (!dataType && !(data instanceof CompressedObject)) {\n            throw new Error(\"The data of '\" + name + \"' is in an unsupported format !\");\n        }\n\n        // special case : it's way easier to work with Uint8Array than with ArrayBuffer\n        if (dataType === \"arraybuffer\") {\n            data = utils.transformTo(\"uint8array\", data);\n        }\n    }\n\n    var object = new ZipObject(name, data, o);\n    this.files[name] = object;\n    return object;\n};\n\n/**\n * Find the parent folder of the path.\n * @private\n * @param {string} path the path to use\n * @return {string} the parent folder, or \"\"\n */\nvar parentFolder = function (path) {\n    if (path.slice(-1) == '/') {\n        path = path.substring(0, path.length - 1);\n    }\n    var lastSlash = path.lastIndexOf('/');\n    return (lastSlash > 0) ? path.substring(0, lastSlash) : \"\";\n};\n\n\n/**\n * Returns the path with a slash at the end.\n * @private\n * @param {String} path the path to check.\n * @return {String} the path with a trailing slash.\n */\nvar forceTrailingSlash = function(path) {\n    // Check the name ends with a /\n    if (path.slice(-1) != \"/\") {\n        path += \"/\"; // IE doesn't like substr(-1)\n    }\n    return path;\n};\n/**\n * Add a (sub) folder in the current folder.\n * @private\n * @param {string} name the folder's name\n * @param {boolean=} [createFolders] If true, automatically create sub\n *  folders. Defaults to false.\n * @return {Object} the new folder.\n */\nvar folderAdd = function(name, createFolders) {\n    createFolders = (typeof createFolders !== 'undefined') ? createFolders : false;\n\n    name = forceTrailingSlash(name);\n\n    // Does this folder already exist?\n    if (!this.files[name]) {\n        fileAdd.call(this, name, null, {\n            dir: true,\n            createFolders: createFolders\n        });\n    }\n    return this.files[name];\n};\n\n/**\n * Generate a JSZip.CompressedObject for a given zipOject.\n * @param {ZipObject} file the object to read.\n * @param {JSZip.compression} compression the compression to use.\n * @param {Object} compressionOptions the options to use when compressing.\n * @return {JSZip.CompressedObject} the compressed result.\n */\nvar generateCompressedObjectFrom = function(file, compression, compressionOptions) {\n    var result = new CompressedObject(),\n        content;\n\n    // the data has not been decompressed, we might reuse things !\n    if (file._data instanceof CompressedObject) {\n        result.uncompressedSize = file._data.uncompressedSize;\n        result.crc32 = file._data.crc32;\n\n        if (result.uncompressedSize === 0 || file.dir) {\n            compression = compressions['STORE'];\n            result.compressedContent = \"\";\n            result.crc32 = 0;\n        }\n        else if (file._data.compressionMethod === compression.magic) {\n            result.compressedContent = file._data.getCompressedContent();\n        }\n        else {\n            content = file._data.getContent();\n            // need to decompress / recompress\n            result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content), compressionOptions);\n        }\n    }\n    else {\n        // have uncompressed data\n        content = getBinaryData(file);\n        if (!content || content.length === 0 || file.dir) {\n            compression = compressions['STORE'];\n            content = \"\";\n        }\n        result.uncompressedSize = content.length;\n        result.crc32 = crc32(content);\n        result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content), compressionOptions);\n    }\n\n    result.compressedSize = result.compressedContent.length;\n    result.compressionMethod = compression.magic;\n\n    return result;\n};\n\n\n\n\n/**\n * Generate the UNIX part of the external file attributes.\n * @param {Object} unixPermissions the unix permissions or null.\n * @param {Boolean} isDir true if the entry is a directory, false otherwise.\n * @return {Number} a 32 bit integer.\n *\n * adapted from http://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute :\n *\n * TTTTsstrwxrwxrwx0000000000ADVSHR\n * ^^^^____________________________ file type, see zipinfo.c (UNX_*)\n *     ^^^_________________________ setuid, setgid, sticky\n *        ^^^^^^^^^________________ permissions\n *                 ^^^^^^^^^^______ not used ?\n *                           ^^^^^^ DOS attribute bits : Archive, Directory, Volume label, System file, Hidden, Read only\n */\nvar generateUnixExternalFileAttr = function (unixPermissions, isDir) {\n\n    var result = unixPermissions;\n    if (!unixPermissions) {\n        // I can't use octal values in strict mode, hence the hexa.\n        //  040775 => 0x41fd\n        // 0100664 => 0x81b4\n        result = isDir ? 0x41fd : 0x81b4;\n    }\n\n    return (result & 0xFFFF) << 16;\n};\n\n/**\n * Generate the DOS part of the external file attributes.\n * @param {Object} dosPermissions the dos permissions or null.\n * @param {Boolean} isDir true if the entry is a directory, false otherwise.\n * @return {Number} a 32 bit integer.\n *\n * Bit 0     Read-Only\n * Bit 1     Hidden\n * Bit 2     System\n * Bit 3     Volume Label\n * Bit 4     Directory\n * Bit 5     Archive\n */\nvar generateDosExternalFileAttr = function (dosPermissions, isDir) {\n\n    // the dir flag is already set for compatibility\n\n    return (dosPermissions || 0)  & 0x3F;\n};\n\n/**\n * Generate the various parts used in the construction of the final zip file.\n * @param {string} name the file name.\n * @param {ZipObject} file the file content.\n * @param {JSZip.CompressedObject} compressedObject the compressed object.\n * @param {number} offset the current offset from the start of the zip file.\n * @param {String} platform let's pretend we are this platform (change platform dependents fields)\n * @return {object} the zip parts.\n */\nvar generateZipParts = function(name, file, compressedObject, offset, platform) {\n    var data = compressedObject.compressedContent,\n        utfEncodedFileName = utils.transformTo(\"string\", utf8.utf8encode(file.name)),\n        comment = file.comment || \"\",\n        utfEncodedComment = utils.transformTo(\"string\", utf8.utf8encode(comment)),\n        useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,\n        useUTF8ForComment = utfEncodedComment.length !== comment.length,\n        o = file.options,\n        dosTime,\n        dosDate,\n        extraFields = \"\",\n        unicodePathExtraField = \"\",\n        unicodeCommentExtraField = \"\",\n        dir, date;\n\n\n    // handle the deprecated options.dir\n    if (file._initialMetadata.dir !== file.dir) {\n        dir = file.dir;\n    } else {\n        dir = o.dir;\n    }\n\n    // handle the deprecated options.date\n    if(file._initialMetadata.date !== file.date) {\n        date = file.date;\n    } else {\n        date = o.date;\n    }\n\n    var extFileAttr = 0;\n    var versionMadeBy = 0;\n    if (dir) {\n        // dos or unix, we set the dos dir flag\n        extFileAttr |= 0x00010;\n    }\n    if(platform === \"UNIX\") {\n        versionMadeBy = 0x031E; // UNIX, version 3.0\n        extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);\n    } else { // DOS or other, fallback to DOS\n        versionMadeBy = 0x0014; // DOS, version 2.0\n        extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);\n    }\n\n    // date\n    // @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html\n    // @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html\n    // @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html\n\n    dosTime = date.getHours();\n    dosTime = dosTime << 6;\n    dosTime = dosTime | date.getMinutes();\n    dosTime = dosTime << 5;\n    dosTime = dosTime | date.getSeconds() / 2;\n\n    dosDate = date.getFullYear() - 1980;\n    dosDate = dosDate << 4;\n    dosDate = dosDate | (date.getMonth() + 1);\n    dosDate = dosDate << 5;\n    dosDate = dosDate | date.getDate();\n\n    if (useUTF8ForFileName) {\n        // set the unicode path extra field. unzip needs at least one extra\n        // field to correctly handle unicode path, so using the path is as good\n        // as any other information. This could improve the situation with\n        // other archive managers too.\n        // This field is usually used without the utf8 flag, with a non\n        // unicode path in the header (winrar, winzip). This helps (a bit)\n        // with the messy Windows' default compressed folders feature but\n        // breaks on p7zip which doesn't seek the unicode path extra field.\n        // So for now, UTF-8 everywhere !\n        unicodePathExtraField =\n            // Version\n            decToHex(1, 1) +\n            // NameCRC32\n            decToHex(crc32(utfEncodedFileName), 4) +\n            // UnicodeName\n            utfEncodedFileName;\n\n        extraFields +=\n            // Info-ZIP Unicode Path Extra Field\n            \"\\x75\\x70\" +\n            // size\n            decToHex(unicodePathExtraField.length, 2) +\n            // content\n            unicodePathExtraField;\n    }\n\n    if(useUTF8ForComment) {\n\n        unicodeCommentExtraField =\n            // Version\n            decToHex(1, 1) +\n            // CommentCRC32\n            decToHex(this.crc32(utfEncodedComment), 4) +\n            // UnicodeName\n            utfEncodedComment;\n\n        extraFields +=\n            // Info-ZIP Unicode Path Extra Field\n            \"\\x75\\x63\" +\n            // size\n            decToHex(unicodeCommentExtraField.length, 2) +\n            // content\n            unicodeCommentExtraField;\n    }\n\n    var header = \"\";\n\n    // version needed to extract\n    header += \"\\x0A\\x00\";\n    // general purpose bit flag\n    // set bit 11 if utf8\n    header += (useUTF8ForFileName || useUTF8ForComment) ? \"\\x00\\x08\" : \"\\x00\\x00\";\n    // compression method\n    header += compressedObject.compressionMethod;\n    // last mod file time\n    header += decToHex(dosTime, 2);\n    // last mod file date\n    header += decToHex(dosDate, 2);\n    // crc-32\n    header += decToHex(compressedObject.crc32, 4);\n    // compressed size\n    header += decToHex(compressedObject.compressedSize, 4);\n    // uncompressed size\n    header += decToHex(compressedObject.uncompressedSize, 4);\n    // file name length\n    header += decToHex(utfEncodedFileName.length, 2);\n    // extra field length\n    header += decToHex(extraFields.length, 2);\n\n\n    var fileRecord = signature.LOCAL_FILE_HEADER + header + utfEncodedFileName + extraFields;\n\n    var dirRecord = signature.CENTRAL_FILE_HEADER +\n    // version made by (00: DOS)\n    decToHex(versionMadeBy, 2) +\n    // file header (common to file and central directory)\n    header +\n    // file comment length\n    decToHex(utfEncodedComment.length, 2) +\n    // disk number start\n    \"\\x00\\x00\" +\n    // internal file attributes TODO\n    \"\\x00\\x00\" +\n    // external file attributes\n    decToHex(extFileAttr, 4) +\n    // relative offset of local header\n    decToHex(offset, 4) +\n    // file name\n    utfEncodedFileName +\n    // extra field\n    extraFields +\n    // file comment\n    utfEncodedComment;\n\n    return {\n        fileRecord: fileRecord,\n        dirRecord: dirRecord,\n        compressedObject: compressedObject\n    };\n};\n\n\n// return the actual prototype of JSZip\nvar out = {\n    /**\n     * Read an existing zip and merge the data in the current JSZip object.\n     * The implementation is in jszip-load.js, don't forget to include it.\n     * @param {String|ArrayBuffer|Uint8Array|Buffer} stream  The stream to load\n     * @param {Object} options Options for loading the stream.\n     *  options.base64 : is the stream in base64 ? default : false\n     * @return {JSZip} the current JSZip object\n     */\n    load: function(stream, options) {\n        throw new Error(\"Load method is not defined. Is the file jszip-load.js included ?\");\n    },\n\n    /**\n     * Filter nested files/folders with the specified function.\n     * @param {Function} search the predicate to use :\n     * function (relativePath, file) {...}\n     * It takes 2 arguments : the relative path and the file.\n     * @return {Array} An array of matching elements.\n     */\n    filter: function(search) {\n        var result = [],\n            filename, relativePath, file, fileClone;\n        for (filename in this.files) {\n            if (!this.files.hasOwnProperty(filename)) {\n                continue;\n            }\n            file = this.files[filename];\n            // return a new object, don't let the user mess with our internal objects :)\n            fileClone = new ZipObject(file.name, file._data, extend(file.options));\n            relativePath = filename.slice(this.root.length, filename.length);\n            if (filename.slice(0, this.root.length) === this.root && // the file is in the current root\n            search(relativePath, fileClone)) { // and the file matches the function\n                result.push(fileClone);\n            }\n        }\n        return result;\n    },\n\n    /**\n     * Add a file to the zip file, or search a file.\n     * @param   {string|RegExp} name The name of the file to add (if data is defined),\n     * the name of the file to find (if no data) or a regex to match files.\n     * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded\n     * @param   {Object} o     File options\n     * @return  {JSZip|Object|Array} this JSZip object (when adding a file),\n     * a file (when searching by string) or an array of files (when searching by regex).\n     */\n    file: function(name, data, o) {\n        if (arguments.length === 1) {\n            if (utils.isRegExp(name)) {\n                var regexp = name;\n                return this.filter(function(relativePath, file) {\n                    return !file.dir && regexp.test(relativePath);\n                });\n            }\n            else { // text\n                return this.filter(function(relativePath, file) {\n                    return !file.dir && relativePath === name;\n                })[0] || null;\n            }\n        }\n        else { // more than one argument : we have data !\n            name = this.root + name;\n            fileAdd.call(this, name, data, o);\n        }\n        return this;\n    },\n\n    /**\n     * Add a directory to the zip file, or search.\n     * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.\n     * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.\n     */\n    folder: function(arg) {\n        if (!arg) {\n            return this;\n        }\n\n        if (utils.isRegExp(arg)) {\n            return this.filter(function(relativePath, file) {\n                return file.dir && arg.test(relativePath);\n            });\n        }\n\n        // else, name is a new folder\n        var name = this.root + arg;\n        var newFolder = folderAdd.call(this, name);\n\n        // Allow chaining by returning a new object with this folder as the root\n        var ret = this.clone();\n        ret.root = newFolder.name;\n        return ret;\n    },\n\n    /**\n     * Delete a file, or a directory and all sub-files, from the zip\n     * @param {string} name the name of the file to delete\n     * @return {JSZip} this JSZip object\n     */\n    remove: function(name) {\n        name = this.root + name;\n        var file = this.files[name];\n        if (!file) {\n            // Look for any folders\n            if (name.slice(-1) != \"/\") {\n                name += \"/\";\n            }\n            file = this.files[name];\n        }\n\n        if (file && !file.dir) {\n            // file\n            delete this.files[name];\n        } else {\n            // maybe a folder, delete recursively\n            var kids = this.filter(function(relativePath, file) {\n                return file.name.slice(0, name.length) === name;\n            });\n            for (var i = 0; i < kids.length; i++) {\n                delete this.files[kids[i].name];\n            }\n        }\n\n        return this;\n    },\n\n    /**\n     * Generate the complete zip file\n     * @param {Object} options the options to generate the zip file :\n     * - base64, (deprecated, use type instead) true to generate base64.\n     * - compression, \"STORE\" by default.\n     * - type, \"base64\" by default. Values are : string, base64, uint8array, arraybuffer, blob.\n     * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the zip file\n     */\n    generate: function(options) {\n        options = extend(options || {}, {\n            base64: true,\n            compression: \"STORE\",\n            compressionOptions : null,\n            type: \"base64\",\n            platform: \"DOS\",\n            comment: null,\n            mimeType: 'application/zip'\n        });\n\n        utils.checkSupport(options.type);\n\n        // accept nodejs `process.platform`\n        if(\n          options.platform === 'darwin' ||\n          options.platform === 'freebsd' ||\n          options.platform === 'linux' ||\n          options.platform === 'sunos'\n        ) {\n          options.platform = \"UNIX\";\n        }\n        if (options.platform === 'win32') {\n          options.platform = \"DOS\";\n        }\n\n        var zipData = [],\n            localDirLength = 0,\n            centralDirLength = 0,\n            writer, i,\n            utfEncodedComment = utils.transformTo(\"string\", this.utf8encode(options.comment || this.comment || \"\"));\n\n        // first, generate all the zip parts.\n        for (var name in this.files) {\n            if (!this.files.hasOwnProperty(name)) {\n                continue;\n            }\n            var file = this.files[name];\n\n            var compressionName = file.options.compression || options.compression.toUpperCase();\n            var compression = compressions[compressionName];\n            if (!compression) {\n                throw new Error(compressionName + \" is not a valid compression method !\");\n            }\n            var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};\n\n            var compressedObject = generateCompressedObjectFrom.call(this, file, compression, compressionOptions);\n\n            var zipPart = generateZipParts.call(this, name, file, compressedObject, localDirLength, options.platform);\n            localDirLength += zipPart.fileRecord.length + compressedObject.compressedSize;\n            centralDirLength += zipPart.dirRecord.length;\n            zipData.push(zipPart);\n        }\n\n        var dirEnd = \"\";\n\n        // end of central dir signature\n        dirEnd = signature.CENTRAL_DIRECTORY_END +\n        // number of this disk\n        \"\\x00\\x00\" +\n        // number of the disk with the start of the central directory\n        \"\\x00\\x00\" +\n        // total number of entries in the central directory on this disk\n        decToHex(zipData.length, 2) +\n        // total number of entries in the central directory\n        decToHex(zipData.length, 2) +\n        // size of the central directory   4 bytes\n        decToHex(centralDirLength, 4) +\n        // offset of start of central directory with respect to the starting disk number\n        decToHex(localDirLength, 4) +\n        // .ZIP file comment length\n        decToHex(utfEncodedComment.length, 2) +\n        // .ZIP file comment\n        utfEncodedComment;\n\n\n        // we have all the parts (and the total length)\n        // time to create a writer !\n        var typeName = options.type.toLowerCase();\n        if(typeName===\"uint8array\"||typeName===\"arraybuffer\"||typeName===\"blob\"||typeName===\"nodebuffer\") {\n            writer = new Uint8ArrayWriter(localDirLength + centralDirLength + dirEnd.length);\n        }else{\n            writer = new StringWriter(localDirLength + centralDirLength + dirEnd.length);\n        }\n\n        for (i = 0; i < zipData.length; i++) {\n            writer.append(zipData[i].fileRecord);\n            writer.append(zipData[i].compressedObject.compressedContent);\n        }\n        for (i = 0; i < zipData.length; i++) {\n            writer.append(zipData[i].dirRecord);\n        }\n\n        writer.append(dirEnd);\n\n        var zip = writer.finalize();\n\n\n\n        switch(options.type.toLowerCase()) {\n            // case \"zip is an Uint8Array\"\n            case \"uint8array\" :\n            case \"arraybuffer\" :\n            case \"nodebuffer\" :\n               return utils.transformTo(options.type.toLowerCase(), zip);\n            case \"blob\" :\n               return utils.arrayBuffer2Blob(utils.transformTo(\"arraybuffer\", zip), options.mimeType);\n            // case \"zip is a string\"\n            case \"base64\" :\n               return (options.base64) ? base64.encode(zip) : zip;\n            default : // case \"string\" :\n               return zip;\n         }\n\n    },\n\n    /**\n     * @deprecated\n     * This method will be removed in a future version without replacement.\n     */\n    crc32: function (input, crc) {\n        return crc32(input, crc);\n    },\n\n    /**\n     * @deprecated\n     * This method will be removed in a future version without replacement.\n     */\n    utf8encode: function (string) {\n        return utils.transformTo(\"string\", utf8.utf8encode(string));\n    },\n\n    /**\n     * @deprecated\n     * This method will be removed in a future version without replacement.\n     */\n    utf8decode: function (input) {\n        return utf8.utf8decode(input);\n    }\n};\nmodule.exports = out;\n"]}