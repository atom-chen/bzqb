{"version":3,"sources":["utf8.js"],"names":["utils","require","support","nodeBuffer","_utf8len","Array","i","string2buf","str","buf","c","c2","m_pos","str_len","length","buf_len","charCodeAt","uint8array","Uint8Array","utf8border","max","pos","buf2string","out","c_len","len","utf16buf","subarray","applyFromCharCode","exports","utf8encode","nodebuffer","utf8decode","transformTo","toString","result","k","chunk","nextBoundary","Math","min","push","slice","join"],"mappings":"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","file":"utf8.js","sourceRoot":"..\\..\\..\\..\\..\\..\\assets\\framework\\lib\\jszip","sourcesContent":["'use strict';\n\nvar utils = require('./utils');\nvar support = require('./support');\nvar nodeBuffer = require('./nodeBuffer');\n\n/**\n * The following functions come from pako, from pako/lib/utils/strings\n * released under the MIT license, see pako https://github.com/nodeca/pako/\n */\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new Array(256);\nfor (var i=0; i<256; i++) {\n  _utf8len[i] = (i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1);\n}\n_utf8len[254]=_utf8len[254]=1; // Invalid sequence start\n\n// convert string to array (typed, when possible)\nvar string2buf = function (str) {\n    var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n    // count binary size\n    for (m_pos = 0; m_pos < str_len; m_pos++) {\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {\n            c2 = str.charCodeAt(m_pos+1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n                m_pos++;\n            }\n        }\n        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n    }\n\n    // allocate buffer\n    if (support.uint8array) {\n        buf = new Uint8Array(buf_len);\n    } else {\n        buf = new Array(buf_len);\n    }\n\n    // convert\n    for (i=0, m_pos = 0; i < buf_len; m_pos++) {\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {\n            c2 = str.charCodeAt(m_pos+1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n                m_pos++;\n            }\n        }\n        if (c < 0x80) {\n            /* one byte */\n            buf[i++] = c;\n        } else if (c < 0x800) {\n            /* two bytes */\n            buf[i++] = 0xC0 | (c >>> 6);\n            buf[i++] = 0x80 | (c & 0x3f);\n        } else if (c < 0x10000) {\n            /* three bytes */\n            buf[i++] = 0xE0 | (c >>> 12);\n            buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n            buf[i++] = 0x80 | (c & 0x3f);\n        } else {\n            /* four bytes */\n            buf[i++] = 0xf0 | (c >>> 18);\n            buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n            buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n            buf[i++] = 0x80 | (c & 0x3f);\n        }\n    }\n\n    return buf;\n};\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nvar utf8border = function(buf, max) {\n    var pos;\n\n    max = max || buf.length;\n    if (max > buf.length) { max = buf.length; }\n\n    // go back from last position, until start of sequence found\n    pos = max-1;\n    while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n    // Fuckup - very small and broken sequence,\n    // return max, because we should return something anyway.\n    if (pos < 0) { return max; }\n\n    // If we came to start of buffer - that means vuffer is too small,\n    // return max too.\n    if (pos === 0) { return max; }\n\n    return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n\n// convert array to string\nvar buf2string = function (buf) {\n    var str, i, out, c, c_len;\n    var len = buf.length;\n\n    // Reserve max possible length (2 words per char)\n    // NB: by unknown reasons, Array is significantly faster for\n    //     String.fromCharCode.apply than Uint16Array.\n    var utf16buf = new Array(len*2);\n\n    for (out=0, i=0; i<len;) {\n        c = buf[i++];\n        // quick process ascii\n        if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n        c_len = _utf8len[c];\n        // skip 5 & 6 byte codes\n        if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len-1; continue; }\n\n        // apply mask on first byte\n        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n        // join the rest\n        while (c_len > 1 && i < len) {\n            c = (c << 6) | (buf[i++] & 0x3f);\n            c_len--;\n        }\n\n        // terminated by end of string?\n        if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n        if (c < 0x10000) {\n            utf16buf[out++] = c;\n        } else {\n            c -= 0x10000;\n            utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n            utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n        }\n    }\n\n    // shrinkBuf(utf16buf, out)\n    if (utf16buf.length !== out) {\n        if(utf16buf.subarray) {\n            utf16buf = utf16buf.subarray(0, out);\n        } else {\n            utf16buf.length = out;\n        }\n    }\n\n    // return String.fromCharCode.apply(null, utf16buf);\n    return utils.applyFromCharCode(utf16buf);\n};\n\n\n// That's all for the pako functions.\n\n\n/**\n * Transform a javascript string into an array (typed if possible) of bytes,\n * UTF-8 encoded.\n * @param {String} str the string to encode\n * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.\n */\nexports.utf8encode = function utf8encode(str) {\n    if (support.nodebuffer) {\n        return nodeBuffer(str, \"utf-8\");\n    }\n\n    return string2buf(str);\n};\n\n\n/**\n * Transform a bytes array (or a representation) representing an UTF-8 encoded\n * string into a javascript string.\n * @param {Array|Uint8Array|Buffer} buf the data de decode\n * @return {String} the decoded string.\n */\nexports.utf8decode = function utf8decode(buf) {\n    if (support.nodebuffer) {\n        return utils.transformTo(\"nodebuffer\", buf).toString(\"utf-8\");\n    }\n\n    buf = utils.transformTo(support.uint8array ? \"uint8array\" : \"array\", buf);\n\n    // return buf2string(buf);\n    // Chrome prefers to work with \"small\" chunks of data\n    // for the method buf2string.\n    // Firefox and Chrome has their own shortcut, IE doesn't seem to really care.\n    var result = [], k = 0, len = buf.length, chunk = 65536;\n    while (k < len) {\n        var nextBoundary = utf8border(buf, Math.min(k + chunk, len));\n        if (support.uint8array) {\n            result.push(buf2string(buf.subarray(k, nextBoundary)));\n        } else {\n            result.push(buf2string(buf.slice(k, nextBoundary)));\n        }\n        k = nextBoundary;\n    }\n    return result.join(\"\");\n\n};\n// vim: set shiftwidth=4 softtabstop=4:\n"]}